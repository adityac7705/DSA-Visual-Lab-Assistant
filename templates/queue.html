<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Queue Visualization</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background: #181825; font-family: 'Poppins', sans-serif; }
    #queue-row { display: flex; align-items: center; min-height: 120px; margin: 0 auto; width: fit-content;}
    .queue-element {
      min-width: 60px; height: 60px;
      border-radius: 8px; font-weight: 600; font-size: 1.4rem; color: #ede9fe;
      box-shadow: 0 0 12px #8b5cf6; margin: 0 5px; background: rgba(110,231,183,0.8);
      border: 2px solid #059669; position: relative;
      display: flex; justify-content: center; align-items: center;
      transition: transform 0.5s cubic-bezier(.77,0,.18,1), opacity 0.5s cubic-bezier(.77,0,.18,1);
      z-index: 1;
    }
    .queue-element.front, .queue-element.rear {
      background: rgba(147,197,253,0.93);
      border: 2px solid #2563eb;
      color: #1e40af;
      text-shadow: 0 0 2px #1e40af;
    }
    .queue-label {
      position: absolute; left: 50%; top: 100%; transform: translate(-50%, 8px); font-weight: 700; font-size: 0.9rem;
      color: #a78bfa; white-space: nowrap; user-select: none; text-shadow: 0 0 5px #c4b5fd; pointer-events: none; z-index: 2;
    }
    .queue-label.rear-pointer { transform: translate(-50%, 36px); }
    .empty-queue {
      min-width: 120px; height: 60px; border-radius: 8px; display: flex; justify-content: center; align-items: center;
      font-weight: 700; font-size: 1.2rem; color: #8b5cf6; border: 2px dashed #8b5cf6; margin: 0 5px; background: transparent;
    }
    .slide-in-right { animation: slideInRight 0.5s cubic-bezier(.77,0,.18,1);}
    @keyframes slideInRight {
      from { transform: translateX(120px) scale(0.7); opacity: 0; }
      to   { transform: translateX(0) scale(1); opacity: 1; }
    }
    .slide-out-left { animation: slideOutLeft 0.5s cubic-bezier(.77,0,.18,1);}
    @keyframes slideOutLeft {
      from { transform: translateX(0) scale(1); opacity: 1; }
      to   { transform: translateX(-120px) scale(0.7); opacity: 0; }
    }
    #queue-visual-wrapper { background: #232334; border-radius: 18px; padding: 40px; min-width: 600px; position: relative; margin: 0 auto; margin-top: 20px;}
  </style>
</head>
<body class="p-8 text-white">
<h1 class="text-4xl font-bold text-center text-purple-400 mb-8">Queue Visualization</h1>
<div class="max-w-3xl mx-auto mb-8 rounded-lg p-6 bg-gray-900 border border-purple-700 text-purple-300 text-lg leading-relaxed">
  <h2 class="text-2xl font-bold mb-2 text-purple-400">Queue Data Structure - Theory</h2>
  <p>A <strong>Queue</strong> is a linear data structure that follows the <strong>First In, First Out (FIFO)</strong> principle.</p>
  <p>This means the first element added (<em>enqueued</em>) to the queue will be the first one removed (<em>dequeued</em>).</p>
  <p>New elements can only be added at the <strong>rear (back)</strong> of the queue and elements can only be removed from the <strong>front (head)</strong>.</p>
  <p>Queues are used in many real-life and computing scenarios such as task scheduling, buffering, breadth-first search algorithms, and more.</p>
  <p>Key terms:
    <ul class="list-disc pl-5 mt-2">
      <li><strong>Front/Head:</strong> The position of the earliest element to be removed.</li>
      <li><strong>Rear/Tail:</strong> The position where the newest element is added.</li>
      <li><strong>Enqueue:</strong> Operation to insert an element at the rear.</li>
      <li><strong>Dequeue:</strong> Operation to remove an element from the front.</li>
    </ul>
  </p>
</div>
<div class="bg-gray-900 p-6 max-w-3xl mx-auto rounded-xl shadow-lg border border-purple-700 mb-8">
  <h2 class="text-xl font-semibold mb-3 text-purple-400">Queue Operations</h2>
  <textarea id="opsInput" rows="7" class="w-full p-3 bg-gray-800 border border-purple-600 rounded-lg text-purple-300 mb-3"
    placeholder="Enter operations line by line (e.g., enqueue A, dequeue)"></textarea>
  <div class="flex gap-3">
    <button id="loadOpsBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-lg transition duration-150">
      Load & Run Simulation
    </button>
    <button id="nextStepBtn" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-6 rounded-lg transition duration-150" disabled>
      Simulate Next Step (Step <span id="currentStepCount">0</span>/<span id="totalStepsCount">0</span>)
    </button>
  </div>
  <div class="mt-3 p-3 bg-purple-900 border-l-4 border-purple-600 text-purple-300 text-sm rounded">
    <strong>Last Operation:</strong> <span id="currentOpDisplay" class="font-medium">N/A</span>
  </div>
</div>
<div id="queue-visual-wrapper" class="mx-auto">
  <div id="queue-row"></div>
</div>
<script>
const queueRow = document.getElementById('queue-row');
const opsInput = document.getElementById('opsInput');
const loadOpsBtn = document.getElementById('loadOpsBtn');
const nextStepBtn = document.getElementById('nextStepBtn');
const currentOpDisplay = document.getElementById('currentOpDisplay');
const currentStepCount = document.getElementById('currentStepCount');
const totalStepsCount = document.getElementById('totalStepsCount');

let allSteps = [];
let currentStepIndex = 0;

function processQueueOps(rawOps) {
  let queue = [];
  let results = [{ queue: [], rawOp: 'Start (Empty queue)', action: 'init', value: null }];
  for (let raw of rawOps) {
    let op = raw.trim().toLowerCase();
    if (op.startsWith('enqueue ')) {
      let value = op.slice(8).trim();
      if (value) {
        queue.push(value);
        results.push({ queue: [...queue], rawOp: raw, action: 'enqueue', value });
      }
    } else if (op.startsWith('dequeue')) {
      if (queue.length) {
        let removed = queue.shift();
        results.push({ queue: [...queue], rawOp: raw, action: 'dequeue', value: removed });
      } else {
        results.push({ queue: [], rawOp: raw, action: 'dequeue (error)', value: null });
      }
    }
  }
  return results;
}

function renderStep(step, lastStep) {
  queueRow.innerHTML = "";
  const q = step.queue || [];
  if (q.length === 0) {
    const emptyBox = document.createElement("div");
    emptyBox.className = "empty-queue";
    emptyBox.textContent = "Empty Queue";
    queueRow.appendChild(emptyBox);
    currentOpDisplay.textContent = "Queue is empty";
    return;
  }
  let elements = [];
  q.forEach((val, i) => {
    let el = document.createElement("div");
    el.className = "queue-element";
    if (q.length === 1) el.classList.add("front", "rear");
    else if (i === 0) el.classList.add("front");
    else if (i === q.length - 1) el.classList.add("rear");
    el.textContent = val;
    if (i === 0) {
      const label = document.createElement("div");
      label.className = "queue-label";
      label.textContent = "Front / Head";
      el.appendChild(label);
    }
    if (i === q.length - 1) {
      const label = document.createElement("div");
      label.className = "queue-label rear-pointer";
      label.textContent = "Back / Tail / Rear";
      el.appendChild(label);
    }
    elements.push(el);
  });

  let displayText = step.rawOp;
  if (step.action === 'enqueue' && step.value !== null) {
    elements[elements.length - 1].classList.add("slide-in-right");
    elements.forEach(e => queueRow.appendChild(e));
    displayText += ` (Element ${step.value} added)`;
  }
  else if (step.action === 'dequeue' && step.value !== null) {
    elements[0].classList.add("slide-out-left");
    elements.forEach(e => queueRow.appendChild(e));
    setTimeout(() => { if (elements[0]) elements[0].style.visibility = "hidden"; }, 480);
    displayText += ` (Element ${step.value} removed)`;
  }
  else {
    elements.forEach(e => queueRow.appendChild(e));
  }
  currentOpDisplay.textContent = displayText;
}
function loadOperations() {
  queueRow.innerHTML = "Calculating steps...";
  const rawOps = opsInput.value.trim().split('\n').filter(line => line.trim());
  allSteps = processQueueOps(rawOps);
  currentStepIndex = 0;
  if (allSteps.length > 0) {
    renderStep(allSteps[0], null);
    currentStepIndex = 1;
  }
  nextStepBtn.disabled = allSteps.length <= 1;
  updateControls();
}
function handleNextStep() {
  if (currentStepIndex < allSteps.length) {
    renderStep(allSteps[currentStepIndex], allSteps[currentStepIndex - 1] || null);
    currentStepIndex++;
    updateControls();
  }
}
function updateControls() {
  let total = allSteps.length > 0 ? allSteps.length - 1 : 0;
  currentStepCount.textContent = currentStepIndex;
  totalStepsCount.textContent = total;
  nextStepBtn.textContent =
    currentStepIndex === allSteps.length
      ? "Simulation Finished! Click Load to Reset."
      : `Simulate Step ${currentStepIndex} of ${total}`;
}
loadOpsBtn.addEventListener('click', loadOperations);
nextStepBtn.addEventListener('click', handleNextStep);
document.addEventListener('DOMContentLoaded', loadOperations);
</script>
</body>
</html>
